package info.russtyuf;

//~--- non-JDK imports --------------------------------------------------------

import com.google.common.base.Joiner;
import com.google.common.base.Splitter;
import com.google.common.collect.Lists;
import org.ini4j.Ini;
import org.ini4j.InvalidFileFormatException;

import java.io.*;
import java.util.*;

//~--- JDK imports ------------------------------------------------------------

/**
 * Class that contains the list of codes for MyCokeRewards and methods store and retrieve the codes.
 * codes can have a value of 3, 8, 10, 15, 18, 20, 24, 25 or 30
 *
 * @author Rusty
 */
public class Codes implements Serializable {
  protected static final Integer[] VALUES = new Integer[]{
      3, 8, 10, 15, 18, 20, 24, 25, 30
  };
  private ArrayList<String> currentList;
  private HashMap<Integer, ArrayList<String>> valueMap;
  private UserPref pref;


  /**
   * Constructs ...
   */
  public Codes() {
    pref = new UserPref();
    valueMap = new HashMap<Integer, ArrayList<String>>();

    for (Integer value : VALUES) {
      valueMap.put(value, new ArrayList<String>());
    }
  }

  /**
   * Adds the code to the ArrayList of the correct value
   *
   * @param value value of the code, can be 3, 8, 10, 15, 18, 20, 24, 25 or 30
   * @param code  the actual code to be saved
   */
  public void addCode(int value, String code) {
    currentList = valueMap.get(value);
    if (!currentList.contains(code)) {
      currentList.add(code);
      save(pref.getCodeFile());
    }
  }

  /**
   * Will remove the code from the ArrayList of supplied value
   *
   * @param value the value of the code to be removed.
   * @param code  the code to be removed
   */
  public void removeCode(int value, String code) {
    currentList = valueMap.get(value);
    currentList.remove(code);
    save(pref.getCodeFile());
  }

  /**
   * Get a code of supplied value
   *
   * @param value value of desired code
   * @return a code of the supplied value if there there are any else it returns null
   * @should return code or null
   */
  public String getCode(int value) {
    return valueMap.get(value).isEmpty()
        ? null
        : valueMap.get(value).get(0);
  }

  /**
   * Method description
   *
   * @param value the value you are checking for
   * @return true if there are codes saved of value supplied
   */
  public boolean isCodeOfValue(int value) {
    return !valueMap.get(value).isEmpty();
  }

  /**
   * Attempt to check validity of codes before adding to list. Codes have to be either 12 or 14 characters long
   * and can only contain: A B F H J K L M N P R T V W X O S U 4 5 6 7 9 0 8
   *
   * @param code the code to check the validity of
   * @return true if the code is a valid code, else false
   * @should return false for invalid code
   */
  public boolean checkCode(String code) {
    Splitter splitter = Splitter.fixedLength(1).trimResults().omitEmptyStrings();
    ArrayList<String> chars = Lists.newArrayList(splitter.split("abfhjklmnprtvwxosu4567908"));

    ArrayList<String> codeList = Lists.newArrayList(splitter.split(code.toLowerCase()));

    return !(!((codeList.size() == 12) || (codeList.size() == 14)) || !chars.containsAll(codeList));
  }

  /**
   * This method returns a string that prints out why the supplied code is invalid
   *
   * @param code code to determine why it is invalid
   * @return returns a string stating the validity of code
   */
  public String whyNotValidCode(String code) {
    String msg = "is valid";
    Splitter splitter = Splitter.fixedLength(1).trimResults().omitEmptyStrings();
    ArrayList<String> chars = Lists.newArrayList(splitter.split("abfhjklmnprtvwxosu4567908"));

    ArrayList<String> codeList = Lists.newArrayList(splitter.split(code.toLowerCase()));

    if (!((codeList.size() == 12) || (codeList.size() == 14))) {
      msg = "Code is not a valid length";
    } else if (!chars.containsAll(codeList)) {
      msg = "Code contains illegal Characters.";
    }
    return msg;
  }

  /**
   * export codes in valueMap to a config file, plaintext
   * @param selectedFile, file to export codes to.
   */
  public void export(File selectedFile) {
    try {
      Ini ini = new Ini();

      for (Integer key : valueMap.keySet()) {
        ini.put("Codes", key.toString(), Joiner.on(",").join(valueMap.get(key)));
      }

      ini.store(selectedFile);
    } catch (InvalidFileFormatException e) {
      e.printStackTrace();    // To change body of catch statement use File | Settings | File Templates.
    } catch (IOException e) {
      e.printStackTrace();    // To change body of catch statement use File | Settings | File Templates.
    }
  }

  /**
   * import file generated by export
   *
   * @param selectedFile, file to open
   */
  public void openImport(File selectedFile) {
    try {
      Ini ini = new Ini();

      ini.load(selectedFile);

      Map<String, String> map = ini.get("Codes");

      for (Map.Entry<String, String> s : map.entrySet()) {
        Splitter splitter = Splitter.on(",").omitEmptyStrings().trimResults();

        for (String code : splitter.split(s.getValue())) {
          addCode(Integer.parseInt(s.getKey()), code);
        }
      }
    } catch (InvalidFileFormatException e) {
      e.printStackTrace();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  public void save(File codeFile) {
    try {
      FileOutputStream fileOutputStream = new FileOutputStream(codeFile);
      ObjectOutputStream outputStream = new ObjectOutputStream(fileOutputStream);
      outputStream.writeObject(valueMap);
      outputStream.close();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  public void openMerge(File selectedFile) {
    FileInputStream fileInputStream = null;
    try {
      fileInputStream = new FileInputStream(selectedFile);
      ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
      Object code = objectInputStream.readObject();
      HashMap<Integer, ArrayList<String>> newCodes = (HashMap<Integer, ArrayList<String>>) code;
      mergeCodes(newCodes);
      objectInputStream.close();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  private void mergeCodes(HashMap<Integer, ArrayList<String>> newCodes) {
    for (Map.Entry<Integer, ArrayList<String>> setEntry : newCodes.entrySet()) {
      for (String code : setEntry.getValue()) {
        addCode(setEntry.getKey(), code);
      }
    }
  }

  public String makeReport() {
    ArrayList<String> msg = new ArrayList<String>();
    int total = 0;
    for (int key : valueMap.keySet()) {
      int size = valueMap.get(key).size();
      if (size != 0) {
        msg.add(size + "\t" + key + " Point codes");
        total += key*size;
      }
    }
    msg.add("Total of " + total + " Points. \n");

    return Joiner.on("\n").join(msg);
  }
}

